<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MasSocket è°ƒè¯•é¡µé¢</title>
  <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18",
        "react-dom/client": "https://esm.sh/react-dom@18/client"
      }
    }
  </script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      padding: 20px;
      background: #f5f5f5;
      height: 100vh;
      overflow: hidden;
    }
    .container {
      display: flex;
      gap: 20px;
      height: calc(100vh - 40px);
      max-width: 1600px;
      margin: 0 auto;
    }
    .left-panel {
      flex: 0 0 650px;
      overflow-y: auto;
      overflow-x: hidden;
      background: white;
      border-radius: 8px;
      padding: 20px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    .left-panel::-webkit-scrollbar {
      width: 8px;
    }
    .left-panel::-webkit-scrollbar-track {
      background: #f1f1f1;
      border-radius: 4px;
    }
    .left-panel::-webkit-scrollbar-thumb {
      background: #888;
      border-radius: 4px;
    }
    .left-panel::-webkit-scrollbar-thumb:hover {
      background: #555;
    }
    .right-panel {
      flex: 1;
      display: flex;
      flex-direction: column;
      background: white;
      border-radius: 8px;
      padding: 20px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      min-width: 0;
    }
    h1 {
      margin-bottom: 20px;
      margin-top: 0;
      color: #333;
      font-size: 24px;
    }
    .right-panel h2 {
      margin-top: 0;
    }
    .section {
      margin-bottom: 30px;
      padding: 15px;
      background: #fafafa;
      border-radius: 6px;
      border-left: 4px solid #007bff;
    }
    .section h2 {
      margin-bottom: 15px;
      color: #007bff;
      font-size: 18px;
    }
    .controls {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      margin-bottom: 15px;
    }
    button {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      background: #007bff;
      color: white;
      cursor: pointer;
      font-size: 14px;
      transition: background 0.2s;
    }
    button:hover {
      background: #0056b3;
    }
    button:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    button.danger {
      background: #dc3545;
    }
    button.danger:hover {
      background: #c82333;
    }
    button.success {
      background: #28a745;
    }
    button.success:hover {
      background: #218838;
    }
    input, select {
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
    }
    .input-group {
      display: flex;
      gap: 10px;
      margin-bottom: 10px;
      align-items: center;
    }
    .input-group label {
      min-width: 100px;
      font-weight: 500;
    }
    .log-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }
    .log-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }
    .log {
      flex: 1;
      background: #1e1e1e;
      color: #d4d4d4;
      padding: 15px;
      border-radius: 4px;
      font-family: 'Courier New', monospace;
      font-size: 12px;
      overflow-y: auto;
      overflow-x: auto;
      min-height: 0;
    }
    .log::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }
    .log::-webkit-scrollbar-track {
      background: #2d2d2d;
      border-radius: 4px;
    }
    .log::-webkit-scrollbar-thumb {
      background: #555;
      border-radius: 4px;
    }
    .log::-webkit-scrollbar-thumb:hover {
      background: #777;
    }
    .log-entry {
      margin-bottom: 5px;
      padding: 4px 0;
      border-bottom: 1px solid #333;
    }
    .log-entry.info { color: #4ec9b0; }
    .log-entry.success { color: #4ec9b0; }
    .log-entry.error { color: #f48771; }
    .log-entry.warn { color: #dcdcaa; }
    .status {
      display: inline-flex;
      align-items: center;
      padding: 0px 8px;
      border-radius: 4px;
      font-size: 12px;
      font-weight: 500;
    }
    .status.connected { background: #28a745; color: white; }
    .status.disconnected { background: #dc3545; color: white; }
    .status.connecting { background: #ffc107; color: #333; }
  </style>
</head>
<body>
  <div id="root"></div>
  
  <script src="../dist/client/index.iife.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script type="text/babel" data-type="module">
    import React, { useState, useEffect, useRef } from 'react';
    import { createRoot } from 'react-dom/client';

    function App() {
      const [serverUrl, setServerUrl] = useState('ws://localhost:3000');
      const [status, setStatus] = useState('disconnected');
      const [eventName, setEventName] = useState('message');
      const [fetchEvent, setFetchEvent] = useState('ping');
      const [fetchData, setFetchData] = useState('{"message": "hello"}');
      const [maxWait, setMaxWait] = useState(10000);
      const [maxReconnect, setMaxReconnect] = useState(5);
      const [groupName, setGroupName] = useState('');
      const [broadcastGroupName, setBroadcastGroupName] = useState('');
      const [broadcastMessage, setBroadcastMessage] = useState('');
      const [logs, setLogs] = useState([]);
      const clientRef = useRef(null);
      const statusCheckIntervalRef = useRef(null);
      const logContainerRef = useRef(null);

      const log = (message, type = 'info') => {
        const time = new Date().toLocaleTimeString();
        setLogs(prev => [...prev, { time, message, type }]);
      };

      const clearLog = () => {
        setLogs([]);
      };

      const updateStatus = (newStatus) => {
        setStatus(newStatus);
      };

      const connect = () => {
        if (!serverUrl) {
          log('è¯·è¾“å…¥æœåŠ¡å™¨åœ°å€', 'error');
          return;
        }

        try {
          clientRef.current = new MasSocketClinet();
          updateStatus('connecting');
          log(`æ­£åœ¨è¿æ¥åˆ° ${serverUrl}...`, 'info');

          clientRef.current.onDisconnect = () => {
            updateStatus('disconnected');
            log('è¿æ¥å·²æ–­å¼€', 'warn');
            if (statusCheckIntervalRef.current) {
              clearInterval(statusCheckIntervalRef.current);
              statusCheckIntervalRef.current = null;
            }
          };

          // ç›‘å¬ç³»ç»Ÿ ID äº‹ä»¶
          clientRef.current.on('_system_id', async ({ body }) => {
            log(`âœ… æ”¶åˆ°ç³»ç»Ÿ ID: ${body.data.id}`, 'success');
          });

          // ç›‘å¬å¹¿æ’­æ¶ˆæ¯äº‹ä»¶
          clientRef.current.on('broadcast-message', async ({ reply, body }) => {
            log(`ğŸ“¨ [å¹¿æ’­æ¶ˆæ¯] æ¥è‡ª ${body.data.from}: ${body.data.message}`, 'success');
            log(`   æ—¶é—´: ${body.data.timestamp}`, 'info');
            reply({
              code: 200,
              data: { received: true },
              msg: 'Broadcast received'
            });
          });

          clientRef.current.connect(serverUrl);
          
          // ç›‘å¬è¿æ¥çŠ¶æ€å˜åŒ–
          statusCheckIntervalRef.current = setInterval(() => {
            if (clientRef.current) {
              const config = clientRef.current.getConfig();
              if (config.status === 'connected') {
                updateStatus('connected');
                log('è¿æ¥æˆåŠŸï¼', 'success');
                if (statusCheckIntervalRef.current) {
                  clearInterval(statusCheckIntervalRef.current);
                  statusCheckIntervalRef.current = null;
                }
              } else if (config.status === 'disconnected' && config.status !== 'connecting') {
                updateStatus('disconnected');
                log('è¿æ¥å¤±è´¥', 'error');
                if (statusCheckIntervalRef.current) {
                  clearInterval(statusCheckIntervalRef.current);
                  statusCheckIntervalRef.current = null;
                }
              }
            }
          }, 100);

          setTimeout(() => {
            if (statusCheckIntervalRef.current) {
              clearInterval(statusCheckIntervalRef.current);
              statusCheckIntervalRef.current = null;
            }
          }, 5000);

        } catch (error) {
          log(`è¿æ¥é”™è¯¯: ${error.message}`, 'error');
          updateStatus('disconnected');
        }
      };

      const disconnect = () => {
        if (clientRef.current) {
          clientRef.current.close();
          clientRef.current = null;
          updateStatus('disconnected');
          log('å·²æ–­å¼€è¿æ¥', 'info');
          if (statusCheckIntervalRef.current) {
            clearInterval(statusCheckIntervalRef.current);
            statusCheckIntervalRef.current = null;
          }
        }
      };

      const registerEventHandler = () => {
        if (!clientRef.current) {
          log('è¯·å…ˆè¿æ¥æœåŠ¡å™¨', 'error');
          return;
        }

        if (!eventName) {
          log('è¯·è¾“å…¥äº‹ä»¶åç§°', 'error');
          return;
        }

        clientRef.current.on(eventName, async ({ reply, body, fetchId, header }) => {
          log(`æ”¶åˆ°äº‹ä»¶ [${eventName}]: ${JSON.stringify(body)}`, 'success');
          log(`  fetchId: ${fetchId}`, 'info');
          log(`  header: ${JSON.stringify(header)}`, 'info');
          
          reply({
            code: 200,
            data: { received: true, event: eventName },
            msg: 'Event received'
          });
        });

        log(`å·²æ³¨å†Œäº‹ä»¶ç›‘å¬å™¨: ${eventName}`, 'success');
      };

      const testEchoEvent = () => {
        if (!clientRef.current) {
          log('è¯·å…ˆè¿æ¥æœåŠ¡å™¨', 'error');
          return;
        }

        clientRef.current.on('echo', async ({ reply, body }) => {
          log(`Echo äº‹ä»¶: ${JSON.stringify(body)}`, 'success');
          reply({
            code: 200,
            data: { echo: body.data },
            msg: 'Echo success'
          });
        });

        log('å·²æ³¨å†Œ Echo äº‹ä»¶ç›‘å¬å™¨', 'success');
      };

      const testTimeEvent = () => {
        if (!clientRef.current) {
          log('è¯·å…ˆè¿æ¥æœåŠ¡å™¨', 'error');
          return;
        }

        clientRef.current.on('time', async ({ reply, body }) => {
          const now = new Date().toISOString();
          log(`Time äº‹ä»¶: ${JSON.stringify(body)}`, 'success');
          reply({
            code: 200,
            data: { time: now },
            msg: 'Time success'
          });
        });

        log('å·²æ³¨å†Œ Time äº‹ä»¶ç›‘å¬å™¨', 'success');
      };

      const sendFetch = async () => {
        if (!clientRef.current) {
          log('è¯·å…ˆè¿æ¥æœåŠ¡å™¨', 'error');
          return;
        }

        if (!fetchEvent) {
          log('è¯·è¾“å…¥äº‹ä»¶åç§°', 'error');
          return;
        }

        let data;
        try {
          data = fetchData ? JSON.parse(fetchData) : {};
        } catch (e) {
          log('æ•°æ®æ ¼å¼é”™è¯¯ï¼Œä½¿ç”¨ç©ºå¯¹è±¡', 'warn');
          data = {};
        }

        try {
          log(`å‘é€è¯·æ±‚: ${fetchEvent}`, 'info');
          const response = await clientRef.current.fetch(fetchEvent, data);
          log(`æ”¶åˆ°å›å¤: ${JSON.stringify(response)}`, 'success');
        } catch (error) {
          log(`è¯·æ±‚å¤±è´¥: ${error.message}`, 'error');
        }
      };

      const sendFetchNoReply = async () => {
        if (!clientRef.current) {
          log('è¯·å…ˆè¿æ¥æœåŠ¡å™¨', 'error');
          return;
        }

        if (!fetchEvent) {
          log('è¯·è¾“å…¥äº‹ä»¶åç§°', 'error');
          return;
        }

        let data;
        try {
          data = fetchData ? JSON.parse(fetchData) : {};
        } catch (e) {
          log('æ•°æ®æ ¼å¼é”™è¯¯ï¼Œä½¿ç”¨ç©ºå¯¹è±¡', 'warn');
          data = {};
        }

        try {
          log(`å‘é€è¯·æ±‚(æ— å›å¤): ${fetchEvent}`, 'info');
          await clientRef.current.fetch(fetchEvent, data, { hasReply: false });
          log('è¯·æ±‚å·²å‘é€ï¼ˆæ— å›å¤ï¼‰', 'success');
        } catch (error) {
          log(`è¯·æ±‚å¤±è´¥: ${error.message}`, 'error');
        }
      };

      const registerMiddleware = () => {
        if (!clientRef.current) {
          log('è¯·å…ˆè¿æ¥æœåŠ¡å™¨', 'error');
          return;
        }

        clientRef.current.use(async ({ body, fetchId, header }) => {
          log(`[ä¸­é—´ä»¶] æ”¶åˆ°æ¶ˆæ¯: ${JSON.stringify(body)}`, 'info');
          log(`[ä¸­é—´ä»¶] fetchId: ${fetchId}`, 'info');
        });

        log('å·²æ³¨å†Œæ—¥å¿—ä¸­é—´ä»¶', 'success');
      };

      const testMiddlewareEvent = () => {
        if (!clientRef.current) {
          log('è¯·å…ˆè¿æ¥æœåŠ¡å™¨', 'error');
          return;
        }

        clientRef.current.on('middleware-test', async ({ reply, body }) => {
          log(`ä¸­é—´ä»¶æµ‹è¯•äº‹ä»¶: ${JSON.stringify(body)}`, 'success');
          reply({
            code: 200,
            data: { processed: true },
            msg: 'Processed by middleware'
          });
        });

        log('å·²æ³¨å†Œä¸­é—´ä»¶æµ‹è¯•äº‹ä»¶ç›‘å¬å™¨', 'success');
      };

      const updateConfig = () => {
        if (!clientRef.current) {
          log('è¯·å…ˆè¿æ¥æœåŠ¡å™¨', 'error');
          return;
        }

        clientRef.current.setConfig({
          maxReconnectCount: maxReconnect,
          maxConnectTimeout: maxWait
        });

        clientRef.current.fetchConfig = {
          ...clientRef.current.fetchConfig,
          maxWait: maxWait
        };

        log(`é…ç½®å·²æ›´æ–°: maxWait=${maxWait}, maxReconnect=${maxReconnect}`, 'success');
      };

      const showConfig = () => {
        if (!clientRef.current) {
          log('è¯·å…ˆè¿æ¥æœåŠ¡å™¨', 'error');
          return;
        }

        const config = clientRef.current.getConfig();
        log(`å½“å‰é…ç½®: ${JSON.stringify(config, null, 2)}`, 'info');
        log(`fetchConfig: ${JSON.stringify(clientRef.current.fetchConfig, null, 2)}`, 'info');
      };

      const joinGroup = async () => {
        if (!clientRef.current) {
          log('è¯·å…ˆè¿æ¥æœåŠ¡å™¨', 'error');
          return;
        }

        if (!groupName) {
          log('è¯·è¾“å…¥ç»„å', 'error');
          return;
        }

        try {
          log(`æ­£åœ¨åŠ å…¥ç»„: ${groupName}`, 'info');
          const response = await clientRef.current.fetch('join-group', { group: groupName });
          log(`âœ… åŠ å…¥ç»„æˆåŠŸ: ${JSON.stringify(response)}`, 'success');
        } catch (error) {
          log(`åŠ å…¥ç»„å¤±è´¥: ${error.message}`, 'error');
        }
      };

      const leaveGroup = async () => {
        if (!clientRef.current) {
          log('è¯·å…ˆè¿æ¥æœåŠ¡å™¨', 'error');
          return;
        }

        if (!groupName) {
          log('è¯·è¾“å…¥ç»„å', 'error');
          return;
        }

        try {
          log(`æ­£åœ¨ç¦»å¼€ç»„: ${groupName}`, 'info');
          const response = await clientRef.current.fetch('leave-group', { group: groupName });
          log(`âœ… ç¦»å¼€ç»„æˆåŠŸ: ${JSON.stringify(response)}`, 'success');
        } catch (error) {
          log(`ç¦»å¼€ç»„å¤±è´¥: ${error.message}`, 'error');
        }
      };

      const sendBroadcast = async () => {
        if (!clientRef.current) {
          log('è¯·å…ˆè¿æ¥æœåŠ¡å™¨', 'error');
          return;
        }

        if (!broadcastGroupName) {
          log('è¯·è¾“å…¥ç»„å', 'error');
          return;
        }

        if (!broadcastMessage) {
          log('è¯·è¾“å…¥æ¶ˆæ¯å†…å®¹', 'error');
          return;
        }

        try {
          log(`ğŸ“£ æ­£åœ¨å‘ç»„ ${broadcastGroupName} å¹¿æ’­æ¶ˆæ¯...`, 'info');
          const response = await clientRef.current.fetch('broadcast', {
            group: broadcastGroupName,
            message: broadcastMessage
          });
          log(`âœ… å¹¿æ’­æˆåŠŸ: ${JSON.stringify(response)}`, 'success');
        } catch (error) {
          log(`å¹¿æ’­å¤±è´¥: ${error.message}`, 'error');
        }
      };

      useEffect(() => {
        log('é¡µé¢å·²åŠ è½½ï¼Œè¯·è¿æ¥æœåŠ¡å™¨å¼€å§‹æµ‹è¯•', 'info');
        return () => {
          if (statusCheckIntervalRef.current) {
            clearInterval(statusCheckIntervalRef.current);
          }
        };
      }, []);

      // è‡ªåŠ¨æ»šåŠ¨æ—¥å¿—åˆ°åº•éƒ¨
      useEffect(() => {
        if (logContainerRef.current) {
          logContainerRef.current.scrollTop = logContainerRef.current.scrollHeight;
        }
      }, [logs]);

      const statusText = status === 'connected' ? 'å·²è¿æ¥' : 
                         status === 'connecting' ? 'è¿æ¥ä¸­' : 'æœªè¿æ¥';

      return (
        <div className="container">
          {/* å·¦ä¾§æ“ä½œé¢æ¿ */}
          <div className="left-panel">
            <h1>ğŸ”Œ MasSocket è°ƒè¯•é¡µé¢</h1>
            
            {/* è¿æ¥æ§åˆ¶ */}
            <div className="section">
              <h2>è¿æ¥æ§åˆ¶</h2>
              <div className="input-group">
                <label>æœåŠ¡å™¨åœ°å€:</label>
                <input
                  type="text"
                  value={serverUrl}
                  onChange={(e) => setServerUrl(e.target.value)}
                  style={{ flex: 1 }}
                />
              </div>
              <div className="controls">
                <button
                  id="connectBtn"
                  onClick={connect}
                  disabled={status === 'connected' || status === 'connecting'}
                >
                  è¿æ¥
                </button>
                <button
                  id="disconnectBtn"
                  onClick={disconnect}
                  disabled={status !== 'connected'}
                  className="danger"
                >
                  æ–­å¼€
                </button>
                <span
                  id="status"
                  className={`status ${status}`}
                >
                  {statusText}
                </span>
              </div>
            </div>

            {/* äº‹ä»¶ç›‘å¬ */}
            <div className="section">
              <h2>äº‹ä»¶ç›‘å¬</h2>
              <div className="input-group">
                <label>äº‹ä»¶åç§°:</label>
                <input
                  type="text"
                  value={eventName}
                  onChange={(e) => setEventName(e.target.value)}
                  placeholder="ä¾‹å¦‚: message"
                />
                <button onClick={registerEventHandler}>æ³¨å†Œç›‘å¬</button>
              </div>
              <div className="controls">
                <button onClick={testEchoEvent}>æµ‹è¯• Echo äº‹ä»¶</button>
                <button onClick={testTimeEvent}>æµ‹è¯•æ—¶é—´äº‹ä»¶</button>
              </div>
            </div>

            {/* è¯·æ±‚-å“åº” */}
            <div className="section">
              <h2>è¯·æ±‚-å“åº” (Fetch)</h2>
              <div className="input-group">
                <label>äº‹ä»¶åç§°:</label>
                <input
                  type="text"
                  value={fetchEvent}
                  onChange={(e) => setFetchEvent(e.target.value)}
                  placeholder="ä¾‹å¦‚: ping"
                />
              </div>
              <div className="input-group">
                <label>è¯·æ±‚æ•°æ®:</label>
                <input
                  type="text"
                  value={fetchData}
                  onChange={(e) => setFetchData(e.target.value)}
                  style={{ flex: 1 }}
                  placeholder="JSON æ ¼å¼"
                />
              </div>
              <div className="controls">
                <button onClick={sendFetch}>å‘é€è¯·æ±‚</button>
                <button onClick={sendFetchNoReply}>å‘é€è¯·æ±‚(æ— å›å¤)</button>
              </div>
            </div>

            {/* ä¸­é—´ä»¶æµ‹è¯• */}
            <div className="section">
              <h2>ä¸­é—´ä»¶æµ‹è¯•</h2>
              <div className="controls">
                <button onClick={registerMiddleware}>æ³¨å†Œæ—¥å¿—ä¸­é—´ä»¶</button>
                <button onClick={testMiddlewareEvent}>æµ‹è¯•ä¸­é—´ä»¶äº‹ä»¶</button>
              </div>
            </div>

            {/* ç»„ç®¡ç† */}
            <div className="section">
              <h2>ç»„ç®¡ç†</h2>
              <div className="input-group">
                <label>ç»„å:</label>
                <input
                  type="text"
                  value={groupName}
                  onChange={(e) => setGroupName(e.target.value)}
                  placeholder="ä¾‹å¦‚: room1"
                  style={{ flex: 1 }}
                />
              </div>
              <div className="controls">
                <button
                  onClick={joinGroup}
                  className="success"
                >
                  åŠ å…¥ç»„
                </button>
                <button
                  onClick={leaveGroup}
                  className="danger"
                >
                  ç¦»å¼€ç»„
                </button>
              </div>
            </div>

            {/* å¹¿æ’­æ¶ˆæ¯ */}
            <div className="section">
              <h2>å¹¿æ’­æ¶ˆæ¯</h2>
              <div className="input-group">
                <label>ç»„å:</label>
                <input
                  type="text"
                  value={broadcastGroupName}
                  onChange={(e) => setBroadcastGroupName(e.target.value)}
                  placeholder="ä¾‹å¦‚: room1"
                  style={{ flex: 1 }}
                />
              </div>
              <div className="input-group">
                <label>æ¶ˆæ¯å†…å®¹:</label>
                <input
                  type="text"
                  value={broadcastMessage}
                  onChange={(e) => setBroadcastMessage(e.target.value)}
                  placeholder="è¾“å…¥è¦å¹¿æ’­çš„æ¶ˆæ¯"
                  style={{ flex: 1 }}
                />
              </div>
              <div className="controls">
                <button
                  onClick={sendBroadcast}
                  className="success"
                >
                  å‘é€å¹¿æ’­
                </button>
              </div>
            </div>

            {/* é…ç½®ç®¡ç† */}
            <div className="section">
              <h2>é…ç½®ç®¡ç†</h2>
              <div className="input-group">
                <label>æœ€å¤§ç­‰å¾…æ—¶é—´:</label>
                <input
                  type="number"
                  value={maxWait}
                  onChange={(e) => setMaxWait(parseInt(e.target.value))}
                  min={1000}
                  step={1000}
                />
                <label>æœ€å¤§é‡è¿æ¬¡æ•°:</label>
                <input
                  type="number"
                  value={maxReconnect}
                  onChange={(e) => setMaxReconnect(parseInt(e.target.value))}
                  min={0}
                  step={1}
                />
              </div>
              <div className="controls">
                <button onClick={updateConfig}>æ›´æ–°é…ç½®</button>
                <button onClick={showConfig}>æ˜¾ç¤ºé…ç½®</button>
              </div>
            </div>
          </div>

          {/* å³ä¾§æ—¥å¿—é¢æ¿ */}
          <div className="right-panel">
            <div className="log-container">
              <div className="log-header">
                <h2>ğŸ“‹ æ—¥å¿—è¾“å‡º</h2>
                <button onClick={clearLog}>æ¸…ç©ºæ—¥å¿—</button>
              </div>
              <div
                id="log"
                className="log"
                ref={logContainerRef}
              >
                {logs.map((logEntry, index) => (
                  <div
                    key={index}
                    className={`log-entry ${logEntry.type}`}
                  >
                    [{logEntry.time}] {logEntry.message}
                  </div>
                ))}
              </div>
            </div>
          </div>
        </div>
      );
    }

    createRoot(document.getElementById('root'))
      .render(<App />);
  </script>
</body>
</html>
