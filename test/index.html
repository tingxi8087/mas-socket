<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MasSocket Ë∞ÉËØïÈ°µÈù¢</title>
  <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18",
        "react-dom/client": "https://esm.sh/react-dom@18/client"
      }
    }
  </script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      padding: 20px;
      background: #f5f5f5;
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
      background: white;
      border-radius: 8px;
      padding: 20px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    h1 {
      margin-bottom: 20px;
      color: #333;
    }
    .section {
      margin-bottom: 30px;
      padding: 15px;
      background: #fafafa;
      border-radius: 6px;
      border-left: 4px solid #007bff;
    }
    .section h2 {
      margin-bottom: 15px;
      color: #007bff;
      font-size: 18px;
    }
    .controls {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      margin-bottom: 15px;
    }
    button {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      background: #007bff;
      color: white;
      cursor: pointer;
      font-size: 14px;
      transition: background 0.2s;
    }
    button:hover {
      background: #0056b3;
    }
    button:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    button.danger {
      background: #dc3545;
    }
    button.danger:hover {
      background: #c82333;
    }
    button.success {
      background: #28a745;
    }
    button.success:hover {
      background: #218838;
    }
    input, select {
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
    }
    .input-group {
      display: flex;
      gap: 10px;
      margin-bottom: 10px;
      align-items: center;
    }
    .input-group label {
      min-width: 100px;
      font-weight: 500;
    }
    .log {
      background: #1e1e1e;
      color: #d4d4d4;
      padding: 15px;
      border-radius: 4px;
      font-family: 'Courier New', monospace;
      font-size: 12px;
      max-height: 400px;
      overflow-y: auto;
      margin-top: 10px;
    }
    .log-entry {
      margin-bottom: 5px;
      padding: 4px 0;
      border-bottom: 1px solid #333;
    }
    .log-entry.info { color: #4ec9b0; }
    .log-entry.success { color: #4ec9b0; }
    .log-entry.error { color: #f48771; }
    .log-entry.warn { color: #dcdcaa; }
    .status {
      display: inline-block;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      font-weight: 500;
    }
    .status.connected { background: #28a745; color: white; }
    .status.disconnected { background: #dc3545; color: white; }
    .status.connecting { background: #ffc107; color: #333; }
  </style>
</head>
<body>
  <div id="root"></div>
  
  <script src="../dist/client/index.iife.js"></script>
  <script type="module">
    import React, { useState, useEffect, useRef } from 'react';
    import { createRoot } from 'react-dom/client';

    function App() {
      const [serverUrl, setServerUrl] = useState('ws://localhost:3000');
      const [status, setStatus] = useState('disconnected');
      const [eventName, setEventName] = useState('message');
      const [fetchEvent, setFetchEvent] = useState('ping');
      const [fetchData, setFetchData] = useState('{"message": "hello"}');
      const [maxWait, setMaxWait] = useState(10000);
      const [maxReconnect, setMaxReconnect] = useState(5);
      const [groupName, setGroupName] = useState('');
      const [broadcastGroupName, setBroadcastGroupName] = useState('');
      const [broadcastMessage, setBroadcastMessage] = useState('');
      const [logs, setLogs] = useState([]);
      const clientRef = useRef(null);
      const statusCheckIntervalRef = useRef(null);

      const log = (message, type = 'info') => {
        const time = new Date().toLocaleTimeString();
        setLogs(prev => [...prev, { time, message, type }]);
      };

      const clearLog = () => {
        setLogs([]);
      };

      const updateStatus = (newStatus) => {
        setStatus(newStatus);
      };

      const connect = () => {
        if (!serverUrl) {
          log('ËØ∑ËæìÂÖ•ÊúçÂä°Âô®Âú∞ÂùÄ', 'error');
          return;
        }

        try {
          clientRef.current = new MasSocketClinet();
          updateStatus('connecting');
          log(`Ê≠£Âú®ËøûÊé•Âà∞ ${serverUrl}...`, 'info');

          clientRef.current.onDisconnect = () => {
            updateStatus('disconnected');
            log('ËøûÊé•Â∑≤Êñ≠ÂºÄ', 'warn');
            if (statusCheckIntervalRef.current) {
              clearInterval(statusCheckIntervalRef.current);
              statusCheckIntervalRef.current = null;
            }
          };

          // ÁõëÂê¨Á≥ªÁªü ID ‰∫ã‰ª∂
          clientRef.current.on('_system_id', async ({ body }) => {
            log(`‚úÖ Êî∂Âà∞Á≥ªÁªü ID: ${body.data.id}`, 'success');
          });

          // ÁõëÂê¨ÂπøÊí≠Ê∂àÊÅØ‰∫ã‰ª∂
          clientRef.current.on('broadcast-message', async ({ reply, body }) => {
            log(`üì® [ÂπøÊí≠Ê∂àÊÅØ] Êù•Ëá™ ${body.data.from}: ${body.data.message}`, 'success');
            log(`   Êó∂Èó¥: ${body.data.timestamp}`, 'info');
            reply({
              code: 200,
              data: { received: true },
              msg: 'Broadcast received'
            });
          });

          clientRef.current.connect(serverUrl);
          
          // ÁõëÂê¨ËøûÊé•Áä∂ÊÄÅÂèòÂåñ
          statusCheckIntervalRef.current = setInterval(() => {
            if (clientRef.current) {
              const config = clientRef.current.getConfig();
              if (config.status === 'connected') {
                updateStatus('connected');
                log('ËøûÊé•ÊàêÂäüÔºÅ', 'success');
                if (statusCheckIntervalRef.current) {
                  clearInterval(statusCheckIntervalRef.current);
                  statusCheckIntervalRef.current = null;
                }
              } else if (config.status === 'disconnected' && config.status !== 'connecting') {
                updateStatus('disconnected');
                log('ËøûÊé•Â§±Ë¥•', 'error');
                if (statusCheckIntervalRef.current) {
                  clearInterval(statusCheckIntervalRef.current);
                  statusCheckIntervalRef.current = null;
                }
              }
            }
          }, 100);

          setTimeout(() => {
            if (statusCheckIntervalRef.current) {
              clearInterval(statusCheckIntervalRef.current);
              statusCheckIntervalRef.current = null;
            }
          }, 5000);

        } catch (error) {
          log(`ËøûÊé•ÈîôËØØ: ${error.message}`, 'error');
          updateStatus('disconnected');
        }
      };

      const disconnect = () => {
        if (clientRef.current) {
          clientRef.current.close();
          clientRef.current = null;
          updateStatus('disconnected');
          log('Â∑≤Êñ≠ÂºÄËøûÊé•', 'info');
          if (statusCheckIntervalRef.current) {
            clearInterval(statusCheckIntervalRef.current);
            statusCheckIntervalRef.current = null;
          }
        }
      };

      const registerEventHandler = () => {
        if (!clientRef.current) {
          log('ËØ∑ÂÖàËøûÊé•ÊúçÂä°Âô®', 'error');
          return;
        }

        if (!eventName) {
          log('ËØ∑ËæìÂÖ•‰∫ã‰ª∂ÂêçÁß∞', 'error');
          return;
        }

        clientRef.current.on(eventName, async ({ reply, body, fetchId, header }) => {
          log(`Êî∂Âà∞‰∫ã‰ª∂ [${eventName}]: ${JSON.stringify(body)}`, 'success');
          log(`  fetchId: ${fetchId}`, 'info');
          log(`  header: ${JSON.stringify(header)}`, 'info');
          
          reply({
            code: 200,
            data: { received: true, event: eventName },
            msg: 'Event received'
          });
        });

        log(`Â∑≤Ê≥®ÂÜå‰∫ã‰ª∂ÁõëÂê¨Âô®: ${eventName}`, 'success');
      };

      const testEchoEvent = () => {
        if (!clientRef.current) {
          log('ËØ∑ÂÖàËøûÊé•ÊúçÂä°Âô®', 'error');
          return;
        }

        clientRef.current.on('echo', async ({ reply, body }) => {
          log(`Echo ‰∫ã‰ª∂: ${JSON.stringify(body)}`, 'success');
          reply({
            code: 200,
            data: { echo: body.data },
            msg: 'Echo success'
          });
        });

        log('Â∑≤Ê≥®ÂÜå Echo ‰∫ã‰ª∂ÁõëÂê¨Âô®', 'success');
      };

      const testTimeEvent = () => {
        if (!clientRef.current) {
          log('ËØ∑ÂÖàËøûÊé•ÊúçÂä°Âô®', 'error');
          return;
        }

        clientRef.current.on('time', async ({ reply, body }) => {
          const now = new Date().toISOString();
          log(`Time ‰∫ã‰ª∂: ${JSON.stringify(body)}`, 'success');
          reply({
            code: 200,
            data: { time: now },
            msg: 'Time success'
          });
        });

        log('Â∑≤Ê≥®ÂÜå Time ‰∫ã‰ª∂ÁõëÂê¨Âô®', 'success');
      };

      const sendFetch = async () => {
        if (!clientRef.current) {
          log('ËØ∑ÂÖàËøûÊé•ÊúçÂä°Âô®', 'error');
          return;
        }

        if (!fetchEvent) {
          log('ËØ∑ËæìÂÖ•‰∫ã‰ª∂ÂêçÁß∞', 'error');
          return;
        }

        let data;
        try {
          data = fetchData ? JSON.parse(fetchData) : {};
        } catch (e) {
          log('Êï∞ÊçÆÊ†ºÂºèÈîôËØØÔºå‰ΩøÁî®Á©∫ÂØπË±°', 'warn');
          data = {};
        }

        try {
          log(`ÂèëÈÄÅËØ∑Ê±Ç: ${fetchEvent}`, 'info');
          const response = await clientRef.current.fetch(fetchEvent, data);
          log(`Êî∂Âà∞ÂõûÂ§ç: ${JSON.stringify(response)}`, 'success');
        } catch (error) {
          log(`ËØ∑Ê±ÇÂ§±Ë¥•: ${error.message}`, 'error');
        }
      };

      const sendFetchNoReply = async () => {
        if (!clientRef.current) {
          log('ËØ∑ÂÖàËøûÊé•ÊúçÂä°Âô®', 'error');
          return;
        }

        if (!fetchEvent) {
          log('ËØ∑ËæìÂÖ•‰∫ã‰ª∂ÂêçÁß∞', 'error');
          return;
        }

        let data;
        try {
          data = fetchData ? JSON.parse(fetchData) : {};
        } catch (e) {
          log('Êï∞ÊçÆÊ†ºÂºèÈîôËØØÔºå‰ΩøÁî®Á©∫ÂØπË±°', 'warn');
          data = {};
        }

        try {
          log(`ÂèëÈÄÅËØ∑Ê±Ç(Êó†ÂõûÂ§ç): ${fetchEvent}`, 'info');
          await clientRef.current.fetch(fetchEvent, data, { hasReply: false });
          log('ËØ∑Ê±ÇÂ∑≤ÂèëÈÄÅÔºàÊó†ÂõûÂ§çÔºâ', 'success');
        } catch (error) {
          log(`ËØ∑Ê±ÇÂ§±Ë¥•: ${error.message}`, 'error');
        }
      };

      const registerMiddleware = () => {
        if (!clientRef.current) {
          log('ËØ∑ÂÖàËøûÊé•ÊúçÂä°Âô®', 'error');
          return;
        }

        clientRef.current.use(async ({ body, fetchId, header }) => {
          log(`[‰∏≠Èó¥‰ª∂] Êî∂Âà∞Ê∂àÊÅØ: ${JSON.stringify(body)}`, 'info');
          log(`[‰∏≠Èó¥‰ª∂] fetchId: ${fetchId}`, 'info');
        });

        log('Â∑≤Ê≥®ÂÜåÊó•Âøó‰∏≠Èó¥‰ª∂', 'success');
      };

      const testMiddlewareEvent = () => {
        if (!clientRef.current) {
          log('ËØ∑ÂÖàËøûÊé•ÊúçÂä°Âô®', 'error');
          return;
        }

        clientRef.current.on('middleware-test', async ({ reply, body }) => {
          log(`‰∏≠Èó¥‰ª∂ÊµãËØï‰∫ã‰ª∂: ${JSON.stringify(body)}`, 'success');
          reply({
            code: 200,
            data: { processed: true },
            msg: 'Processed by middleware'
          });
        });

        log('Â∑≤Ê≥®ÂÜå‰∏≠Èó¥‰ª∂ÊµãËØï‰∫ã‰ª∂ÁõëÂê¨Âô®', 'success');
      };

      const updateConfig = () => {
        if (!clientRef.current) {
          log('ËØ∑ÂÖàËøûÊé•ÊúçÂä°Âô®', 'error');
          return;
        }

        clientRef.current.setConfig({
          maxReconnectCount: maxReconnect,
          maxConnectTimeout: maxWait
        });

        clientRef.current.fetchConfig = {
          ...clientRef.current.fetchConfig,
          maxWait: maxWait
        };

        log(`ÈÖçÁΩÆÂ∑≤Êõ¥Êñ∞: maxWait=${maxWait}, maxReconnect=${maxReconnect}`, 'success');
      };

      const showConfig = () => {
        if (!clientRef.current) {
          log('ËØ∑ÂÖàËøûÊé•ÊúçÂä°Âô®', 'error');
          return;
        }

        const config = clientRef.current.getConfig();
        log(`ÂΩìÂâçÈÖçÁΩÆ: ${JSON.stringify(config, null, 2)}`, 'info');
        log(`fetchConfig: ${JSON.stringify(clientRef.current.fetchConfig, null, 2)}`, 'info');
      };

      const joinGroup = async () => {
        if (!clientRef.current) {
          log('ËØ∑ÂÖàËøûÊé•ÊúçÂä°Âô®', 'error');
          return;
        }

        if (!groupName) {
          log('ËØ∑ËæìÂÖ•ÁªÑÂêç', 'error');
          return;
        }

        try {
          log(`Ê≠£Âú®Âä†ÂÖ•ÁªÑ: ${groupName}`, 'info');
          const response = await clientRef.current.fetch('join-group', { group: groupName });
          log(`‚úÖ Âä†ÂÖ•ÁªÑÊàêÂäü: ${JSON.stringify(response)}`, 'success');
        } catch (error) {
          log(`Âä†ÂÖ•ÁªÑÂ§±Ë¥•: ${error.message}`, 'error');
        }
      };

      const leaveGroup = async () => {
        if (!clientRef.current) {
          log('ËØ∑ÂÖàËøûÊé•ÊúçÂä°Âô®', 'error');
          return;
        }

        if (!groupName) {
          log('ËØ∑ËæìÂÖ•ÁªÑÂêç', 'error');
          return;
        }

        try {
          log(`Ê≠£Âú®Á¶ªÂºÄÁªÑ: ${groupName}`, 'info');
          const response = await clientRef.current.fetch('leave-group', { group: groupName });
          log(`‚úÖ Á¶ªÂºÄÁªÑÊàêÂäü: ${JSON.stringify(response)}`, 'success');
        } catch (error) {
          log(`Á¶ªÂºÄÁªÑÂ§±Ë¥•: ${error.message}`, 'error');
        }
      };

      const sendBroadcast = async () => {
        if (!clientRef.current) {
          log('ËØ∑ÂÖàËøûÊé•ÊúçÂä°Âô®', 'error');
          return;
        }

        if (!broadcastGroupName) {
          log('ËØ∑ËæìÂÖ•ÁªÑÂêç', 'error');
          return;
        }

        if (!broadcastMessage) {
          log('ËØ∑ËæìÂÖ•Ê∂àÊÅØÂÜÖÂÆπ', 'error');
          return;
        }

        try {
          log(`üì£ Ê≠£Âú®ÂêëÁªÑ ${broadcastGroupName} ÂπøÊí≠Ê∂àÊÅØ...`, 'info');
          const response = await clientRef.current.fetch('broadcast', {
            group: broadcastGroupName,
            message: broadcastMessage
          });
          log(`‚úÖ ÂπøÊí≠ÊàêÂäü: ${JSON.stringify(response)}`, 'success');
        } catch (error) {
          log(`ÂπøÊí≠Â§±Ë¥•: ${error.message}`, 'error');
        }
      };

      useEffect(() => {
        log('È°µÈù¢Â∑≤Âä†ËΩΩÔºåËØ∑ËøûÊé•ÊúçÂä°Âô®ÂºÄÂßãÊµãËØï', 'info');
        return () => {
          if (statusCheckIntervalRef.current) {
            clearInterval(statusCheckIntervalRef.current);
          }
        };
      }, []);

      const statusText = status === 'connected' ? 'Â∑≤ËøûÊé•' : 
                         status === 'connecting' ? 'ËøûÊé•‰∏≠' : 'Êú™ËøûÊé•';

      return React.createElement('div', { className: 'container' },
        React.createElement('h1', null, 'üîå MasSocket Ë∞ÉËØïÈ°µÈù¢'),
        
        // ËøûÊé•ÊéßÂà∂
        React.createElement('div', { className: 'section' },
          React.createElement('h2', null, 'ËøûÊé•ÊéßÂà∂'),
          React.createElement('div', { className: 'input-group' },
            React.createElement('label', null, 'ÊúçÂä°Âô®Âú∞ÂùÄ:'),
            React.createElement('input', {
              type: 'text',
              value: serverUrl,
              onChange: (e) => setServerUrl(e.target.value),
              style: { flex: 1 }
            })
          ),
          React.createElement('div', { className: 'controls' },
            React.createElement('button', {
              id: 'connectBtn',
              onClick: connect,
              disabled: status === 'connected' || status === 'connecting'
            }, 'ËøûÊé•'),
            React.createElement('button', {
              id: 'disconnectBtn',
              onClick: disconnect,
              disabled: status !== 'connected',
              className: 'danger'
            }, 'Êñ≠ÂºÄ'),
            React.createElement('span', {
              id: 'status',
              className: `status ${status}`
            }, statusText)
          )
        ),

        // ‰∫ã‰ª∂ÁõëÂê¨
        React.createElement('div', { className: 'section' },
          React.createElement('h2', null, '‰∫ã‰ª∂ÁõëÂê¨'),
          React.createElement('div', { className: 'input-group' },
            React.createElement('label', null, '‰∫ã‰ª∂ÂêçÁß∞:'),
            React.createElement('input', {
              type: 'text',
              value: eventName,
              onChange: (e) => setEventName(e.target.value),
              placeholder: '‰æãÂ¶Ç: message'
            }),
            React.createElement('button', { onClick: registerEventHandler }, 'Ê≥®ÂÜåÁõëÂê¨')
          ),
          React.createElement('div', { className: 'controls' },
            React.createElement('button', { onClick: testEchoEvent }, 'ÊµãËØï Echo ‰∫ã‰ª∂'),
            React.createElement('button', { onClick: testTimeEvent }, 'ÊµãËØïÊó∂Èó¥‰∫ã‰ª∂')
          )
        ),

        // ËØ∑Ê±Ç-ÂìçÂ∫î
        React.createElement('div', { className: 'section' },
          React.createElement('h2', null, 'ËØ∑Ê±Ç-ÂìçÂ∫î (Fetch)'),
          React.createElement('div', { className: 'input-group' },
            React.createElement('label', null, '‰∫ã‰ª∂ÂêçÁß∞:'),
            React.createElement('input', {
              type: 'text',
              value: fetchEvent,
              onChange: (e) => setFetchEvent(e.target.value),
              placeholder: '‰æãÂ¶Ç: ping'
            })
          ),
          React.createElement('div', { className: 'input-group' },
            React.createElement('label', null, 'ËØ∑Ê±ÇÊï∞ÊçÆ:'),
            React.createElement('input', {
              type: 'text',
              value: fetchData,
              onChange: (e) => setFetchData(e.target.value),
              style: { flex: 1 },
              placeholder: 'JSON Ê†ºÂºè'
            })
          ),
          React.createElement('div', { className: 'controls' },
            React.createElement('button', { onClick: sendFetch }, 'ÂèëÈÄÅËØ∑Ê±Ç'),
            React.createElement('button', { onClick: sendFetchNoReply }, 'ÂèëÈÄÅËØ∑Ê±Ç(Êó†ÂõûÂ§ç)')
          )
        ),

        // ‰∏≠Èó¥‰ª∂ÊµãËØï
        React.createElement('div', { className: 'section' },
          React.createElement('h2', null, '‰∏≠Èó¥‰ª∂ÊµãËØï'),
          React.createElement('div', { className: 'controls' },
            React.createElement('button', { onClick: registerMiddleware }, 'Ê≥®ÂÜåÊó•Âøó‰∏≠Èó¥‰ª∂'),
            React.createElement('button', { onClick: testMiddlewareEvent }, 'ÊµãËØï‰∏≠Èó¥‰ª∂‰∫ã‰ª∂')
          )
        ),

        // ÁªÑÁÆ°ÁêÜ
        React.createElement('div', { className: 'section' },
          React.createElement('h2', null, 'ÁªÑÁÆ°ÁêÜ'),
          React.createElement('div', { className: 'input-group' },
            React.createElement('label', null, 'ÁªÑÂêç:'),
            React.createElement('input', {
              type: 'text',
              value: groupName,
              onChange: (e) => setGroupName(e.target.value),
              placeholder: '‰æãÂ¶Ç: room1',
              style: { flex: 1 }
            })
          ),
          React.createElement('div', { className: 'controls' },
            React.createElement('button', { 
              onClick: joinGroup,
              className: 'success'
            }, 'Âä†ÂÖ•ÁªÑ'),
            React.createElement('button', { 
              onClick: leaveGroup,
              className: 'danger'
            }, 'Á¶ªÂºÄÁªÑ')
          )
        ),

        // ÂπøÊí≠Ê∂àÊÅØ
        React.createElement('div', { className: 'section' },
          React.createElement('h2', null, 'ÂπøÊí≠Ê∂àÊÅØ'),
          React.createElement('div', { className: 'input-group' },
            React.createElement('label', null, 'ÁªÑÂêç:'),
            React.createElement('input', {
              type: 'text',
              value: broadcastGroupName,
              onChange: (e) => setBroadcastGroupName(e.target.value),
              placeholder: '‰æãÂ¶Ç: room1',
              style: { flex: 1 }
            })
          ),
          React.createElement('div', { className: 'input-group' },
            React.createElement('label', null, 'Ê∂àÊÅØÂÜÖÂÆπ:'),
            React.createElement('input', {
              type: 'text',
              value: broadcastMessage,
              onChange: (e) => setBroadcastMessage(e.target.value),
              placeholder: 'ËæìÂÖ•Ë¶ÅÂπøÊí≠ÁöÑÊ∂àÊÅØ',
              style: { flex: 1 }
            })
          ),
          React.createElement('div', { className: 'controls' },
            React.createElement('button', { 
              onClick: sendBroadcast,
              className: 'success'
            }, 'ÂèëÈÄÅÂπøÊí≠')
          )
        ),

        // ÈÖçÁΩÆÁÆ°ÁêÜ
        React.createElement('div', { className: 'section' },
          React.createElement('h2', null, 'ÈÖçÁΩÆÁÆ°ÁêÜ'),
          React.createElement('div', { className: 'input-group' },
            React.createElement('label', null, 'ÊúÄÂ§ßÁ≠âÂæÖÊó∂Èó¥:'),
            React.createElement('input', {
              type: 'number',
              value: maxWait,
              onChange: (e) => setMaxWait(parseInt(e.target.value)),
              min: 1000,
              step: 1000
            }),
            React.createElement('label', null, 'ÊúÄÂ§ßÈáçËøûÊ¨°Êï∞:'),
            React.createElement('input', {
              type: 'number',
              value: maxReconnect,
              onChange: (e) => setMaxReconnect(parseInt(e.target.value)),
              min: 0,
              step: 1
            })
          ),
          React.createElement('div', { className: 'controls' },
            React.createElement('button', { onClick: updateConfig }, 'Êõ¥Êñ∞ÈÖçÁΩÆ'),
            React.createElement('button', { onClick: showConfig }, 'ÊòæÁ§∫ÈÖçÁΩÆ')
          )
        ),

        // Êó•ÂøóËæìÂá∫
        React.createElement('div', { className: 'section' },
          React.createElement('h2', null, 'Êó•ÂøóËæìÂá∫'),
          React.createElement('div', { className: 'controls' },
            React.createElement('button', { onClick: clearLog }, 'Ê∏ÖÁ©∫Êó•Âøó')
          ),
          React.createElement('div', {
            id: 'log',
            className: 'log',
            ref: (el) => {
              if (el) {
                el.scrollTop = el.scrollHeight;
              }
            }
          },
            logs.map((logEntry, index) =>
              React.createElement('div', {
                key: index,
                className: `log-entry ${logEntry.type}`
              }, `[${logEntry.time}] ${logEntry.message}`)
            )
          )
        )
      );
    }

    createRoot(document.getElementById('root'))
      .render(React.createElement(App));
  </script>
</body>
</html>
