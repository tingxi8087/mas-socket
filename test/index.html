<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MasSocket è°ƒè¯•é¡µé¢</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      padding: 20px;
      background: #f5f5f5;
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
      background: white;
      border-radius: 8px;
      padding: 20px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    h1 {
      margin-bottom: 20px;
      color: #333;
    }
    .section {
      margin-bottom: 30px;
      padding: 15px;
      background: #fafafa;
      border-radius: 6px;
      border-left: 4px solid #007bff;
    }
    .section h2 {
      margin-bottom: 15px;
      color: #007bff;
      font-size: 18px;
    }
    .controls {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      margin-bottom: 15px;
    }
    button {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      background: #007bff;
      color: white;
      cursor: pointer;
      font-size: 14px;
      transition: background 0.2s;
    }
    button:hover {
      background: #0056b3;
    }
    button:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    button.danger {
      background: #dc3545;
    }
    button.danger:hover {
      background: #c82333;
    }
    button.success {
      background: #28a745;
    }
    button.success:hover {
      background: #218838;
    }
    input, select {
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
    }
    .input-group {
      display: flex;
      gap: 10px;
      margin-bottom: 10px;
      align-items: center;
    }
    .input-group label {
      min-width: 100px;
      font-weight: 500;
    }
    .log {
      background: #1e1e1e;
      color: #d4d4d4;
      padding: 15px;
      border-radius: 4px;
      font-family: 'Courier New', monospace;
      font-size: 12px;
      max-height: 400px;
      overflow-y: auto;
      margin-top: 10px;
    }
    .log-entry {
      margin-bottom: 5px;
      padding: 4px 0;
      border-bottom: 1px solid #333;
    }
    .log-entry.info { color: #4ec9b0; }
    .log-entry.success { color: #4ec9b0; }
    .log-entry.error { color: #f48771; }
    .log-entry.warn { color: #dcdcaa; }
    .status {
      display: inline-block;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      font-weight: 500;
    }
    .status.connected { background: #28a745; color: white; }
    .status.disconnected { background: #dc3545; color: white; }
    .status.connecting { background: #ffc107; color: #333; }
  </style>
</head>
<body>
  <div class="container">
    <h1>ğŸ”Œ MasSocket è°ƒè¯•é¡µé¢</h1>

    <!-- è¿æ¥æ§åˆ¶ -->
    <div class="section">
      <h2>è¿æ¥æ§åˆ¶</h2>
      <div class="input-group">
        <label>æœåŠ¡å™¨åœ°å€:</label>
        <input type="text" id="serverUrl" value="ws://localhost:3000" style="flex: 1;">
      </div>
      <div class="controls">
        <button id="connectBtn" onclick="connect()">è¿æ¥</button>
        <button id="disconnectBtn" onclick="disconnect()" disabled>æ–­å¼€</button>
        <span id="status" class="status disconnected">æœªè¿æ¥</span>
      </div>
    </div>

    <!-- äº‹ä»¶ç›‘å¬ -->
    <div class="section">
      <h2>äº‹ä»¶ç›‘å¬</h2>
      <div class="input-group">
        <label>äº‹ä»¶åç§°:</label>
        <input type="text" id="eventName" value="message" placeholder="ä¾‹å¦‚: message">
        <button onclick="registerEventHandler()">æ³¨å†Œç›‘å¬</button>
      </div>
      <div class="controls">
        <button onclick="testEchoEvent()">æµ‹è¯• Echo äº‹ä»¶</button>
        <button onclick="testTimeEvent()">æµ‹è¯•æ—¶é—´äº‹ä»¶</button>
      </div>
    </div>

    <!-- è¯·æ±‚-å“åº” -->
    <div class="section">
      <h2>è¯·æ±‚-å“åº” (Fetch)</h2>
      <div class="input-group">
        <label>äº‹ä»¶åç§°:</label>
        <input type="text" id="fetchEvent" value="ping" placeholder="ä¾‹å¦‚: ping">
      </div>
      <div class="input-group">
        <label>è¯·æ±‚æ•°æ®:</label>
        <input type="text" id="fetchData" value='{"message": "hello"}' style="flex: 1;" placeholder='JSON æ ¼å¼'>
      </div>
      <div class="controls">
        <button onclick="sendFetch()">å‘é€è¯·æ±‚</button>
        <button onclick="sendFetchNoReply()">å‘é€è¯·æ±‚(æ— å›å¤)</button>
      </div>
    </div>

    <!-- ä¸­é—´ä»¶æµ‹è¯• -->
    <div class="section">
      <h2>ä¸­é—´ä»¶æµ‹è¯•</h2>
      <div class="controls">
        <button onclick="registerMiddleware()">æ³¨å†Œæ—¥å¿—ä¸­é—´ä»¶</button>
        <button onclick="testMiddlewareEvent()">æµ‹è¯•ä¸­é—´ä»¶äº‹ä»¶</button>
      </div>
    </div>

    <!-- é…ç½®ç®¡ç† -->
    <div class="section">
      <h2>é…ç½®ç®¡ç†</h2>
      <div class="input-group">
        <label>æœ€å¤§ç­‰å¾…æ—¶é—´:</label>
        <input type="number" id="maxWait" value="10000" min="1000" step="1000">
        <label>æœ€å¤§é‡è¿æ¬¡æ•°:</label>
        <input type="number" id="maxReconnect" value="5" min="0" step="1">
      </div>
      <div class="controls">
        <button onclick="updateConfig()">æ›´æ–°é…ç½®</button>
        <button onclick="showConfig()">æ˜¾ç¤ºé…ç½®</button>
      </div>
    </div>

    <!-- æ—¥å¿—è¾“å‡º -->
    <div class="section">
      <h2>æ—¥å¿—è¾“å‡º</h2>
      <div class="controls">
        <button onclick="clearLog()">æ¸…ç©ºæ—¥å¿—</button>
      </div>
      <div id="log" class="log"></div>
    </div>
  </div>

  <script src="../dist/client/index.iife.js"></script>
  <script>
    let client = null;

    function log(message, type = 'info') {
      const logEl = document.getElementById('log');
      const entry = document.createElement('div');
      entry.className = `log-entry ${type}`;
      const time = new Date().toLocaleTimeString();
      entry.textContent = `[${time}] ${message}`;
      logEl.appendChild(entry);
      logEl.scrollTop = logEl.scrollHeight;
    }

    function clearLog() {
      document.getElementById('log').innerHTML = '';
    }

    function updateStatus(status) {
      const statusEl = document.getElementById('status');
      statusEl.textContent = status === 'connected' ? 'å·²è¿æ¥' : 
                            status === 'connecting' ? 'è¿æ¥ä¸­' : 'æœªè¿æ¥';
      statusEl.className = `status ${status}`;
      document.getElementById('connectBtn').disabled = status === 'connected' || status === 'connecting';
      document.getElementById('disconnectBtn').disabled = status !== 'connected';
    }

    function connect() {
      const url = document.getElementById('serverUrl').value;
      if (!url) {
        log('è¯·è¾“å…¥æœåŠ¡å™¨åœ°å€', 'error');
        return;
      }

      try {
        client = new MasSocketClinet();
        updateStatus('connecting');
        log(`æ­£åœ¨è¿æ¥åˆ° ${url}...`, 'info');

        client.onDisconnect = () => {
          updateStatus('disconnected');
          log('è¿æ¥å·²æ–­å¼€', 'warn');
        };

        client.connect(url);
        
        // ç›‘å¬è¿æ¥çŠ¶æ€å˜åŒ–
        const checkStatus = setInterval(() => {
          const config = client.getConfig();
          if (config.status === 'connected') {
            updateStatus('connected');
            log('è¿æ¥æˆåŠŸï¼', 'success');
            clearInterval(checkStatus);
          } else if (config.status === 'disconnected' && config.status !== 'connecting') {
            updateStatus('disconnected');
            log('è¿æ¥å¤±è´¥', 'error');
            clearInterval(checkStatus);
          }
        }, 100);

        setTimeout(() => {
          clearInterval(checkStatus);
        }, 5000);

      } catch (error) {
        log(`è¿æ¥é”™è¯¯: ${error.message}`, 'error');
        updateStatus('disconnected');
      }
    }

    function disconnect() {
      if (client) {
        client.close();
        client = null;
        updateStatus('disconnected');
        log('å·²æ–­å¼€è¿æ¥', 'info');
      }
    }

    function registerEventHandler() {
      if (!client) {
        log('è¯·å…ˆè¿æ¥æœåŠ¡å™¨', 'error');
        return;
      }

      const eventName = document.getElementById('eventName').value;
      if (!eventName) {
        log('è¯·è¾“å…¥äº‹ä»¶åç§°', 'error');
        return;
      }

      client.on(eventName, async ({ reply, body, fetchId, header }) => {
        log(`æ”¶åˆ°äº‹ä»¶ [${eventName}]: ${JSON.stringify(body)}`, 'success');
        log(`  fetchId: ${fetchId}`, 'info');
        log(`  header: ${JSON.stringify(header)}`, 'info');
        
        // è‡ªåŠ¨å›å¤
        reply({
          code: 200,
          data: { received: true, event: eventName },
          msg: 'Event received'
        });
      });

      log(`å·²æ³¨å†Œäº‹ä»¶ç›‘å¬å™¨: ${eventName}`, 'success');
    }

    function testEchoEvent() {
      if (!client) {
        log('è¯·å…ˆè¿æ¥æœåŠ¡å™¨', 'error');
        return;
      }

      client.on('echo', async ({ reply, body }) => {
        log(`Echo äº‹ä»¶: ${JSON.stringify(body)}`, 'success');
        reply({
          code: 200,
          data: { echo: body.data },
          msg: 'Echo success'
        });
      });

      log('å·²æ³¨å†Œ Echo äº‹ä»¶ç›‘å¬å™¨', 'success');
    }

    function testTimeEvent() {
      if (!client) {
        log('è¯·å…ˆè¿æ¥æœåŠ¡å™¨', 'error');
        return;
      }

      client.on('time', async ({ reply, body }) => {
        const now = new Date().toISOString();
        log(`Time äº‹ä»¶: ${JSON.stringify(body)}`, 'success');
        reply({
          code: 200,
          data: { time: now },
          msg: 'Time success'
        });
      });

      log('å·²æ³¨å†Œ Time äº‹ä»¶ç›‘å¬å™¨', 'success');
    }

    async function sendFetch() {
      if (!client) {
        log('è¯·å…ˆè¿æ¥æœåŠ¡å™¨', 'error');
        return;
      }

      const event = document.getElementById('fetchEvent').value;
      const dataStr = document.getElementById('fetchData').value;
      
      if (!event) {
        log('è¯·è¾“å…¥äº‹ä»¶åç§°', 'error');
        return;
      }

      let data;
      try {
        data = dataStr ? JSON.parse(dataStr) : {};
      } catch (e) {
        log('æ•°æ®æ ¼å¼é”™è¯¯ï¼Œä½¿ç”¨ç©ºå¯¹è±¡', 'warn');
        data = {};
      }

      try {
        log(`å‘é€è¯·æ±‚: ${event}`, 'info');
        const response = await client.fetch(event, data);
        log(`æ”¶åˆ°å›å¤: ${JSON.stringify(response)}`, 'success');
      } catch (error) {
        log(`è¯·æ±‚å¤±è´¥: ${error.message}`, 'error');
      }
    }

    async function sendFetchNoReply() {
      if (!client) {
        log('è¯·å…ˆè¿æ¥æœåŠ¡å™¨', 'error');
        return;
      }

      const event = document.getElementById('fetchEvent').value;
      const dataStr = document.getElementById('fetchData').value;
      
      if (!event) {
        log('è¯·è¾“å…¥äº‹ä»¶åç§°', 'error');
        return;
      }

      let data;
      try {
        data = dataStr ? JSON.parse(dataStr) : {};
      } catch (e) {
        log('æ•°æ®æ ¼å¼é”™è¯¯ï¼Œä½¿ç”¨ç©ºå¯¹è±¡', 'warn');
        data = {};
      }

      try {
        log(`å‘é€è¯·æ±‚(æ— å›å¤): ${event}`, 'info');
        await client.fetch(event, data, { hasReply: false });
        log('è¯·æ±‚å·²å‘é€ï¼ˆæ— å›å¤ï¼‰', 'success');
      } catch (error) {
        log(`è¯·æ±‚å¤±è´¥: ${error.message}`, 'error');
      }
    }

    function registerMiddleware() {
      if (!client) {
        log('è¯·å…ˆè¿æ¥æœåŠ¡å™¨', 'error');
        return;
      }

      client.use(async ({ body, fetchId, header, reply }) => {
        log(`[ä¸­é—´ä»¶] æ”¶åˆ°æ¶ˆæ¯: ${JSON.stringify(body)}`, 'info');
        log(`[ä¸­é—´ä»¶] fetchId: ${fetchId}`, 'info');
        // ä¸è°ƒç”¨ replyï¼Œç»§ç»­ä¼ é€’
      });

      log('å·²æ³¨å†Œæ—¥å¿—ä¸­é—´ä»¶', 'success');
    }

    function testMiddlewareEvent() {
      if (!client) {
        log('è¯·å…ˆè¿æ¥æœåŠ¡å™¨', 'error');
        return;
      }

      client.on('middleware-test', async ({ reply, body }) => {
        log(`ä¸­é—´ä»¶æµ‹è¯•äº‹ä»¶: ${JSON.stringify(body)}`, 'success');
        reply({
          code: 200,
          data: { processed: true },
          msg: 'Processed by middleware'
        });
      });

      log('å·²æ³¨å†Œä¸­é—´ä»¶æµ‹è¯•äº‹ä»¶ç›‘å¬å™¨', 'success');
    }

    function updateConfig() {
      if (!client) {
        log('è¯·å…ˆè¿æ¥æœåŠ¡å™¨', 'error');
        return;
      }

      const maxWait = parseInt(document.getElementById('maxWait').value);
      const maxReconnect = parseInt(document.getElementById('maxReconnect').value);

      client.setConfig({
        maxReconnectCount: maxReconnect,
        maxConnectTimeout: maxWait
      });

      client.fetchConfig = {
        ...client.fetchConfig,
        maxWait: maxWait
      };

      log(`é…ç½®å·²æ›´æ–°: maxWait=${maxWait}, maxReconnect=${maxReconnect}`, 'success');
    }

    function showConfig() {
      if (!client) {
        log('è¯·å…ˆè¿æ¥æœåŠ¡å™¨', 'error');
        return;
      }

      const config = client.getConfig();
      log(`å½“å‰é…ç½®: ${JSON.stringify(config, null, 2)}`, 'info');
      log(`fetchConfig: ${JSON.stringify(client.fetchConfig, null, 2)}`, 'info');
    }

    // åˆå§‹åŒ–
    log('é¡µé¢å·²åŠ è½½ï¼Œè¯·è¿æ¥æœåŠ¡å™¨å¼€å§‹æµ‹è¯•', 'info');
  </script>
</body>
</html>
